
# Secret Sharing Implementation

## 1. Project Objectives

The goal of this project is to implement a **secret sharing scheme**. A secret will be split among **`m`** people (`2 ≤ m ≤ 65535`) in such a way that the original secret can be reconstructed only when a minimum of **`n`** people (`2 ≤ n ≤ 255`, with `n < m`) combine their individual shares.

You will need to research and implement an appropriate algorithm to achieve this. The recommended approach is **Shamir's Secret Sharing**.

### The Secret Format

The secret is a 16-byte (128-bit) number. For easy handling in the terminal, it is encoded as a hexadecimal string where each byte is separated by a colon (`:`).

**Example Secret:**

1A:E4:78:CA:C4:67:89:12:A4:6E:5F:FB:2D:71:E6:B8

---

### Program 1: `share.py`

This program generates and distributes the secret shares.

*   **Name:** `share.py`
*   **Command-Line Arguments:** It must accept three parameters:
    1.  `m`: The total number of shares to create.
    2.  `n`: The minimum number of shares required for recovery.
    3.  `secret`: The 16-byte secret in the specified hex format.

*   **Example Usage:**
    ```bash
    ./share.py 4 2 1A:E4:78:CA:C4:67:89:12:A4:6E:5F:FB:2D:71:E6:B8
    ```

*   **Output:**
    *   The program must print exactly `m` lines to standard output.
    *   Each line represents one share given to one person.
    *   Each share must be formatted as a colon-separated hexadecimal string (same as the input secret format).
    *   The byte-length of each share may be greater than 16 bytes.
    *   **Crucial Requirement:** The `m` output lines (the shares) must be substantially different from one another.

### Program 2: `recover.py`

This program reconstructs the original secret from a given set of shares.

*   **Name:** `recover.py`
*   **Command-Line Arguments:** It must accept `n` arguments, where each argument is a share generated by `share.py`.

*   **Example Usage** (for n=2):
    *(The `...` is used for brevity and is not part of the actual share)*
    ```bash
    ./recover.py C3:E3:28:...:A1 5F:CA:D6:...:E4
    ```

*   **Output:**
    *   The program must print a single line of text to standard output.
    *   This line must contain the reconstructed secret in the original 16-byte hexadecimal format.

*   **Example Output from the command above:**
    ```
    1A:E4:78:CA:C4:67:89:12:A4:6E:5F:FB:2D:71:E6:B8
    ```

### Performance Constraints

*   Both `share.py` and `recover.py` complete their execution in **less than 10 seconds** for any valid values of `m` and `n`.

---

## 3. Implementation Guidelines

### Core Algorithm: Shamir's Secret Sharing (SSS)

The SSS algorithm is based on the mathematical principle that a unique polynomial of degree `n-1` can be defined by any `n` points on it.

1.  **Sharing:**
    *   Convert the 128-bit secret `S` into a single large integer.
    *   This integer becomes the constant term (`a_0`) of a polynomial of degree `n-1`:
        `P(x) = S + a_1*x + a_2*x^2 + ... + a_{n-1}*x^(n-1)`
    *   The other coefficients (`a_1` to `a_{n-1}`) must be chosen as large, cryptographically secure random numbers.
    *   The `m` shares are created by evaluating the polynomial at `m` distinct, non-zero points (e.g., `x = 1, 2, ..., m`). Each share is a point `(x_i, y_i)`, where `y_i = P(x_i)`.

2.  **Recovery:**
    *   Given `n` shares (points), use **Lagrange Interpolation** to reconstruct the original polynomial.
    *   The secret `S` is the value of the polynomial at `x=0`, which can be calculated directly from the `n` points without finding all the coefficients.

### Finite Field Arithmetic

All polynomial calculations **must** be performed over a **finite field `GF(p)`** to ensure security.
*   You must choose a prime number `p` that is large enough to accommodate the secret and the number of shares.
*   **Recommendation:** Choose a prime `p` that is larger than `2^128` (so the secret fits) and larger than `m` (so you have enough `x` coordinates). A 129-bit or larger prime is a safe choice. Python's native support for arbitrarily large integers is perfect for this.

### Share Formatting

A share consists of a point `(x_i, y_i)`. You must encode this pair into a single hex string.
*   A simple and effective method is to concatenate the byte representations of `x_i` and `y_i`.
*   Since `m <= 65535`, `x_i` can be stored as a **2-byte** integer.
*   `y_i` will be a large number (up to the size of your prime `p`). If you use a 129-bit prime, `y_i` will fit in **17 bytes**.
*   This results in a total share size of `2 + 17 = 19` bytes per share, which can then be formatted into the required hex string.

### Helpful Python Snippets

*   **To parse an input hex string into a large integer:**
    ```python
    hex_string = "1A:E4:78:CA:C4:67:89:12:A4:6E:5F:FB:2D:71:E6:B8"
    byte_data = bytes.fromhex(hex_string.replace(':', ''))
    secret_as_integer = int.from_bytes(byte_data, 'big')
    ```

*   **To format output bytes into the required hex string:**
    ```python
    # e.g., share_data is your 19-byte share
    hex_output = ':'.join(f'{b:02X}' for b in share_data)
    print(hex_output)
    ```

*   **To calculate a modular multiplicative inverse (required for Lagrange Interpolation):**
    *(Requires Python 3.8+)*
    ```python
    # Calculates (number^-1) mod p
    inverse = pow(number, -1, p)
    ```

